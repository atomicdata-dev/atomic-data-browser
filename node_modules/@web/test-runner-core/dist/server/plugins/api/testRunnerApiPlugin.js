"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.testRunnerApiPlugin = void 0;
const dev_server_core_1 = require("@web/dev-server-core");
const constants_1 = require("../../../utils/constants");
const TestSessionStatus_1 = require("../../../test-session/TestSessionStatus");
const parseBrowserResult_1 = require("./parseBrowserResult");
const createSourceMapFunction_1 = require("./createSourceMapFunction");
function createMapBrowserUrl(rootDir) {
    return function mapBrowserUrl(url) {
        if (url.pathname.startsWith('/__web-test-runner__/test-framework')) {
            return url.pathname.substring('/__web-test-runner__/test-framework'.length);
        }
        return dev_server_core_1.getRequestFilePath(url.href, rootDir);
    };
}
class TestRunnerApiPlugin {
    constructor(config, testRunner, sessions, plugins) {
        this.name = 'test-runner-api';
        this.injectWebSocket = true;
        /** key: session id, value: browser url */
        this.testSessionUrls = new Map();
        this.config = config;
        this.testRunner = testRunner;
        this.sessions = sessions;
        this.plugins = plugins;
        this.mapBrowserUrl = createMapBrowserUrl(config.rootDir);
        this.sourceMapFunction = createSourceMapFunction_1.createSourceMapFunction(this.config.protocol, this.config.hostname, this.config.port);
        this.testRunner.on('test-run-started', ({ testRun }) => {
            if (testRun !== 0) {
                // create a new source map function to clear the cached source maps
                this.sourceMapFunction = createSourceMapFunction_1.createSourceMapFunction(this.config.protocol, this.config.hostname, this.config.port);
            }
        });
    }
    getSession(sessionId) {
        const session = this.sessions.get(sessionId) || this.sessions.getDebug(sessionId);
        if (!session) {
            throw new Error(`Session id ${sessionId} not found`);
        }
        return session;
    }
    parseSessionMessage(data) {
        if (typeof data.sessionId === 'string') {
            return { message: data, session: this.getSession(data.sessionId) };
        }
        throw new Error('Missing sessionId in browser websocket message.');
    }
    async transform(context) {
        if (context.response.is('html')) {
            const sessionId = context.URL.searchParams.get(constants_1.PARAM_SESSION_ID);
            if (!sessionId) {
                return;
            }
            try {
                this.testSessionUrls.set(sessionId, `${this.config.protocol}//${this.config.hostname}:${this.config.port}${context.url}`);
            }
            catch (error) {
                this.config.logger.error('Error while creating test file import path');
                this.config.logger.error(error);
                context.status = 500;
            }
        }
    }
    serverStart({ webSockets }) {
        webSockets.on('message', async ({ webSocket, data }) => {
            if (data.type === 'wtr-session-started') {
                this._onSessionStarted(webSocket, data);
                return;
            }
            if (data.type === 'wtr-session-finished') {
                this._onSessionFinished(data);
                return;
            }
            if (data.type === 'wtr-command') {
                this._onCommand(webSocket, data);
                return;
            }
        });
    }
    _onSessionStarted(webSocket, data) {
        if (!data.testFile) {
            // this is a regular test session
            const { session } = this.parseSessionMessage(data);
            if (!session.debug) {
                if (session.status !== TestSessionStatus_1.SESSION_STATUS.INITIALIZING) {
                    this._onMultiInitialized(session);
                    return;
                }
                // mark the session as started
                this.sessions.updateStatus(session, TestSessionStatus_1.SESSION_STATUS.TEST_STARTED);
                this._waitForDisconnect(webSocket, session.id);
            }
        }
    }
    async _onSessionFinished(data) {
        const { session, message } = this.parseSessionMessage(data);
        if (session.debug)
            return;
        if (typeof message.result !== 'object') {
            throw new Error('Missing result in session-finished message.');
        }
        if (!data.userAgent || typeof data.userAgent !== 'string') {
            throw new Error('Missing userAgent in session-finished message.');
        }
        const result = await parseBrowserResult_1.parseBrowserResult(this.config, this.mapBrowserUrl, this.sourceMapFunction, data.userAgent, message.result);
        this.sessions.updateStatus(Object.assign(Object.assign({}, session), result), TestSessionStatus_1.SESSION_STATUS.TEST_FINISHED);
    }
    async _onCommand(webSocket, data) {
        var _a;
        const { session, message } = this.parseSessionMessage(data);
        const { id, command, payload } = message;
        if (typeof id !== 'number')
            throw new Error('Missing message id.');
        if (typeof command !== 'string')
            throw new Error('A command name must be provided.');
        for (const plugin of this.plugins) {
            try {
                const result = await ((_a = plugin.executeCommand) === null || _a === void 0 ? void 0 : _a.call(plugin, { command, payload, session }));
                if (result != null) {
                    webSocket.send(JSON.stringify({
                        type: 'message-response',
                        id,
                        response: { executed: true, result },
                    }));
                    return;
                }
            }
            catch (error) {
                this.config.logger.error(error);
                webSocket.send(JSON.stringify({ type: 'message-response', id, error: error.message }));
                return;
            }
        }
        // no command was matched
        webSocket.send(JSON.stringify({ type: 'message-response', id, response: { executed: false } }));
    }
    /**
     * Waits for web socket to become disconnected, and checks after disconnect if it was expected
     * or if some error occurred.
     */
    _waitForDisconnect(webSocket, sessionId) {
        webSocket.on('close', async () => {
            const session = this.sessions.get(sessionId);
            if ((session === null || session === void 0 ? void 0 : session.status) !== TestSessionStatus_1.SESSION_STATUS.TEST_STARTED) {
                // websocket closed after finishing the tests, this is expected
                return;
            }
            // the websocket disconnected while the tests were still running, this can happen for many reasons.
            // we wait 2000ms (magic number) to let other handlers come up with a more specific error message
            await new Promise(r => setTimeout(r, 2000));
            const updatedSession = this.sessions.get(sessionId);
            if ((updatedSession === null || updatedSession === void 0 ? void 0 : updatedSession.status) !== TestSessionStatus_1.SESSION_STATUS.TEST_STARTED) {
                // something else handled the disconnect
                return;
            }
            const startUrl = this.testSessionUrls.get(updatedSession.id);
            const currentUrl = await updatedSession.browser.getBrowserUrl(updatedSession.id);
            if (!currentUrl || startUrl !== currentUrl) {
                this._setSessionFailed(updatedSession, `Tests were interrupted because the page navigated to ${currentUrl ? currentUrl : 'another origin'}. ` +
                    'This can happen when clicking a link, submitting a form or interacting with window.location.');
            }
            else {
                this._setSessionFailed(updatedSession, 'Tests were interrupted because the browser disconnected.');
            }
        });
    }
    _onMultiInitialized(session) {
        this._setSessionFailed(session, 'Tests were interrupted because the page was reloaded. ' +
            'This can happen when clicking a link, submitting a form or interacting with window.location.');
    }
    _setSessionFailed(session, message) {
        var _a;
        this.sessions.updateStatus(Object.assign(Object.assign({}, session), { errors: [...((_a = session.errors) !== null && _a !== void 0 ? _a : []), { message }] }), TestSessionStatus_1.SESSION_STATUS.TEST_FINISHED);
    }
}
function testRunnerApiPlugin(config, testRunner, sessions, plugins) {
    return new TestRunnerApiPlugin(config, testRunner, sessions, plugins);
}
exports.testRunnerApiPlugin = testRunnerApiPlugin;
//# sourceMappingURL=testRunnerApiPlugin.js.map