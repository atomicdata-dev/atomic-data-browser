"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const oaf_side_effects_1 = require("oaf-side-effects");
const page_state_1 = require("./page-state");
const page_state_memory_1 = require("./page-state-memory");
exports.defaultSettings = {
    announcementsDivId: "announcements",
    primaryFocusTarget: "main h1, [role=main] h1",
    documentTitle: (location) => location.pathname.replace("/", " "),
    // TODO i18n
    navigationMessage: (title) => `Navigated to ${title}.`,
    shouldHandleAction: () => true,
    disableAutoScrollRestoration: true,
    announcePageNavigation: true,
    setPageTitle: true,
    renderTimeout: 0,
    defaultPageState: { x: 0, y: 0 },
    focusOptions: undefined,
    scrollIntoViewOptions: undefined,
};
const disableAutoScrollRestoration = (settings) => {
    // https://developer.mozilla.org/en-US/docs/Web/API/History#Browser_compatibility
    if (settings.disableAutoScrollRestoration &&
        "scrollRestoration" in window.history) {
        const original = window.history.scrollRestoration;
        window.history.scrollRestoration = "manual";
        return () => (window.history.scrollRestoration = original);
    }
    else {
        return () => {
            return;
        };
    }
};
const handleFirstPageLoad = (h, settings) => {
    if (settings.setPageTitle) {
        document.title = settings.documentTitle(h.location);
    }
    setTimeout(() => {
        const focusTarget = oaf_side_effects_1.elementFromHash(h.location.hash);
        if (focusTarget !== undefined) {
            oaf_side_effects_1.focusAndScrollIntoViewIfRequired(focusTarget, focusTarget, settings.focusOptions, settings.scrollIntoViewOptions);
        }
    }, settings.renderTimeout);
};
// HACK we need a way to track where focus and scroll were left on the first loaded page
// but we won't have an entry in history for this initial page, so we just make up a key.
const keyFromLocation = (location) => location.key !== undefined ? location.key : "initial";
exports.wrapHistory = (h, s) => {
    const settings = Object.assign({}, exports.defaultSettings, s);
    const resetAutoScrollRestoration = disableAutoScrollRestoration(settings);
    const pageStateMemory = page_state_memory_1.createPageStateMemory();
    const unlisten = h.listen((location, action) => {
        const title = settings.documentTitle(location);
        if (settings.setPageTitle) {
            document.title = title;
        }
        const locationKey = keyFromLocation(location);
        const shouldHandleAction = pageStateMemory.getShouldHandleAction(locationKey);
        if (shouldHandleAction !== undefined ? shouldHandleAction : true) {
            if (settings.announcePageNavigation) {
                oaf_side_effects_1.announce(settings.navigationMessage(title, location, action), settings.announcementsDivId);
            }
            // HACK: We use setTimeout to give React a chance to render before we repair focus.
            // This may or may not be future proof. Revisit when React 17 is released.
            // We may have to tap into componentDidMount() on the individual react-router Route
            // components to know when we can safely repair focus.
            if (action === "POP") {
                const previousPageState = pageStateMemory.getPageState(locationKey);
                const pageState = Object.assign({}, settings.defaultPageState, previousPageState);
                setTimeout(() => page_state_1.setPageState(pageState, settings.primaryFocusTarget), settings.renderTimeout);
            }
            else {
                setTimeout(() => {
                    oaf_side_effects_1.resetFocus(settings.primaryFocusTarget, oaf_side_effects_1.elementFromHash(location.hash), settings.focusOptions, settings.scrollIntoViewOptions);
                }, settings.renderTimeout);
            }
        }
    });
    // We use `block` because it conveniently gives us access to both the previous and
    // next locations, while we can only get at the next location in `listen`.
    const unblock = h.block((location, action) => {
        const previousLocation = h.location;
        const nextLocation = location;
        const previousLocationKey = keyFromLocation(previousLocation);
        const nextLocationKey = keyFromLocation(nextLocation);
        pageStateMemory.setPageState(previousLocationKey, page_state_1.getPageState());
        if (action === "PUSH") {
            pageStateMemory.handlePushAction(previousLocationKey, nextLocationKey);
        }
        else if (action === "REPLACE") {
            pageStateMemory.handleReplaceAction(previousLocationKey, nextLocationKey);
        }
        pageStateMemory.setShouldHandleAction(nextLocationKey, settings.shouldHandleAction(previousLocation, nextLocation, action));
    });
    // First page load won't be picked up by `listen`.
    handleFirstPageLoad(h, settings);
    return () => {
        resetAutoScrollRestoration();
        unlisten();
        unblock();
    };
};
