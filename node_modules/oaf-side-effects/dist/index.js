"use strict";
// tslint:disable: no-expression-statement
// tslint:disable: no-object-mutation
// tslint:disable: no-if-statement
// tslint:disable: no-console
// tslint:disable: interface-over-type-literal
// tslint:disable: no-try
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Maps from a URL hash fragment to a target element.
 *
 * Supports "#", "#top" and element IDs. The empty string returns undefined.
 *
 * Useful for scrolling to the element referred to by the hash fragment
 * in a URL (which browsers do natively, but single page apps often don't).
 *
 * See https://github.com/rafrex/react-router-hash-link (only manages scroll, not focus)
 * See https://github.com/ReactTraining/react-router/issues/394
 * See https://www.w3.org/TR/html5/single-page.html#scroll-to-the-fragment
 *
 * @param hash the hash fragment, including the leading # character, e.g. "#", "#top" or "#my-heading-id"
 */
exports.elementFromHash = function (hash) {
    if (typeof hash !== "string") {
        return undefined;
    }
    switch (hash) {
        case "#":
            return (document.documentElement || document.body.parentElement || document.body);
        case "":
            return undefined;
        default:
            var element = document.getElementById(hash.substring(1));
            if (element !== null) {
                return element;
            }
            else if (hash === "#top") {
                return (document.documentElement ||
                    document.body.parentElement ||
                    document.body);
            }
            else {
                return undefined;
            }
    }
};
/**
 * Set the document title.
 * See https://www.w3.org/TR/UNDERSTANDING-WCAG20/navigation-mechanisms-title.html
 *
 * @param title The new document title.
 */
exports.setTitle = function (title) {
    if (typeof title !== "string" || title.trim() === "") {
        console.error("Title [" + title + "] is invalid. See https://www.w3.org/TR/UNDERSTANDING-WCAG20/navigation-mechanisms-title.html");
    }
    document.title = title;
    return;
};
/**
 * True if the specified element is within the viewport, false otherwise.
 * See https://stackoverflow.com/questions/123999/how-to-tell-if-a-dom-element-is-visible-in-the-current-viewport/7557433#7557433
 *
 * @param element the element to test
 */
exports.isInViewport = function (element) {
    var rect = element.getBoundingClientRect();
    // TODO: handle overflow-scroll in element's container?
    return (rect.top >= 0 &&
        rect.left >= 0 &&
        rect.bottom <=
            (window.innerHeight || document.documentElement.clientHeight) &&
        rect.right <= (window.innerWidth || document.documentElement.clientWidth));
};
var querySelector = function (selectors, parent) {
    if (parent === void 0) { parent = document; }
    try {
        var result = parent.querySelector(selectors);
        return result === null ? undefined : result;
    }
    catch (_a) {
        console.warn("Syntax error in selector [" + selectors + "].");
        return undefined;
    }
};
exports.elementFromTarget = function (target, parent) {
    if (parent === void 0) { parent = document; }
    return target instanceof Element ? target : querySelector(target, parent);
};
exports.getScrollPosition = function () {
    // See https://developer.mozilla.org/en-US/docs/Web/API/Window/scrollX#Notes
    var documentElement = document.documentElement || document.body.parentNode || document.body;
    var x = window.scrollX || window.pageXOffset || documentElement.scrollLeft;
    var y = window.scrollY || window.pageYOffset || documentElement.scrollTop;
    return { x: x, y: y };
};
/**
 * Scrolls the window to the given scroll position.
 *
 * For smooth scrolling behavior you might want to use the smoothscroll
 * polyfill http://iamdustan.com/smoothscroll/
 *
 * If the user has indicated that they prefer reduced motion, the smoothScroll value will be ignored.
 *
 * @param scrollPosition the scroll position to scroll to
 * @param smoothScroll true for smooth scrolling, false otherwise
 */
exports.setScrollPosition = function (scrollPosition, smoothScroll) {
    if (smoothScroll === void 0) { smoothScroll = false; }
    if (!smoothScroll || exports.prefersReducedMotion()) {
        // Use old form of scrollTo() (when we can) to maximize browser compatibility.
        window.scrollTo(scrollPosition.x, scrollPosition.y);
    }
    else {
        try {
            window.scrollTo({
                behavior: "smooth",
                left: scrollPosition.x,
                top: scrollPosition.y,
            });
        }
        catch (_a) {
            // If scrollTo with options throws, fall back on old form.
            // See https://github.com/Fyrd/caniuse/issues/1760
            // See https://github.com/frontarm/navi/issues/71
            // See https://github.com/frontarm/navi/pull/84/files
            window.scrollTo(scrollPosition.x, scrollPosition.y);
        }
    }
};
var getScrollPositionRestorer = function () {
    var scrollPosition = exports.getScrollPosition();
    return function () {
        // See https://github.com/calvellido/focus-options-polyfill/blob/master/index.js
        // HACK: It seems that we have to call window.scrollTo() twice--once
        // immediately after focus and then again in a setTimeout()--to prevent
        // Firefox from bouncing around the page. TODO: Revisit this.
        exports.setScrollPosition(scrollPosition);
        return new Promise(function (resolve) {
            setTimeout(function () {
                exports.setScrollPosition(scrollPosition);
                resolve();
            });
        });
    };
};
var disableSmoothScroll = function () {
    // See https://caniuse.com/#search=css-scroll-behavior
    // See https://caniuse.com/#search=getcomputedstyle
    var scrollElements = typeof window.getComputedStyle === "function"
        ? [window.document.documentElement, window.document.body]
        : [];
    var smoothScrollElements = scrollElements
        .filter(function (e) { return e !== null && window.getComputedStyle(e).scrollBehavior === "smooth"; })
        .map(function (e) { return ({ element: e, originalScrollBehavior: e.style.scrollBehavior }); });
    smoothScrollElements.forEach(function (_a) {
        var element = _a.element;
        return (element.style.scrollBehavior = "auto");
    });
    // Return a function that will put things back the way we found them.
    return function () {
        smoothScrollElements.forEach(function (_a) {
            var element = _a.element, originalScrollBehavior = _a.originalScrollBehavior;
            return (element.style.scrollBehavior = originalScrollBehavior);
        });
    };
};
/**
 * Executes a function that may (undesirably) change the window's scroll position
 * and then restores the window scroll position and scroll behavior.
 * @param funcWithScrollSideEffect a function to execute that may (undesirably) change the window's scroll position
 */
var withRestoreScrollPosition = function (funcWithScrollSideEffect) { return __awaiter(void 0, void 0, void 0, function () {
    var restoreScrollPosition, restoreScrollBehavior, result;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                restoreScrollPosition = getScrollPositionRestorer();
                restoreScrollBehavior = disableSmoothScroll();
                result = funcWithScrollSideEffect();
                return [4 /*yield*/, restoreScrollPosition()];
            case 1:
                _a.sent();
                // After we're done scrolling set scrollBehavior back to its original value.
                restoreScrollBehavior();
                return [2 /*return*/, result];
        }
    });
}); };
/**
 * Focuses an element, setting `tabindex="-1"` if necessary.
 *
 * @param target the element to focus.
 * @param preventScroll true if the browser should not scroll the target element into view, false otherwise.
 */
exports.focusElement = function (target, preventScroll) {
    if (preventScroll === void 0) { preventScroll = false; }
    return __awaiter(void 0, void 0, void 0, function () {
        var element, blurListener_1, e_1;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    element = exports.elementFromTarget(target);
                    if (element === undefined) {
                        console.warn("Cannot focus element. Element [" + target + "] not found.");
                        return [2 /*return*/, Promise.resolve(false)];
                    }
                    if (!(element instanceof HTMLElement || element instanceof SVGElement)) {
                        console.warn("Cannot focus element. Element [" + target + "] is not an HTMLElement or SVGElement.");
                        return [2 /*return*/, Promise.resolve(false)];
                    }
                    _a.label = 1;
                case 1:
                    _a.trys.push([1, 5, , 6]);
                    // Set tabindex="-1" if necessary.
                    // TODO avoid setting tabindex when we're confident we don't need to?
                    if (!element.hasAttribute("tabindex")) {
                        element.setAttribute("tabindex", "-1");
                        blurListener_1 = function () {
                            element.removeAttribute("tabindex");
                            element.removeEventListener("blur", blurListener_1);
                        };
                        element.addEventListener("blur", blurListener_1);
                    }
                    if (!preventScroll) return [3 /*break*/, 3];
                    // preventScroll has poor browser support, so we restore scroll manually after setting focus.
                    // TODO detect if browser supports preventScroll and avoid `withRestoreScrollPosition`
                    // shenanigans if so.
                    return [4 /*yield*/, withRestoreScrollPosition(function () {
                            try {
                                element.focus({ preventScroll: true });
                            }
                            catch (_a) {
                                // If focus() with options throws, fall back on calling focus() without any arguments.
                                element.focus();
                            }
                        })];
                case 2:
                    // preventScroll has poor browser support, so we restore scroll manually after setting focus.
                    // TODO detect if browser supports preventScroll and avoid `withRestoreScrollPosition`
                    // shenanigans if so.
                    _a.sent();
                    return [3 /*break*/, 4];
                case 3:
                    // Avoid passing anything to focus() (when we can) to maximize browser compatibility.
                    element.focus();
                    _a.label = 4;
                case 4: return [2 /*return*/, document.activeElement === element];
                case 5:
                    e_1 = _a.sent();
                    // Apparently trying to focus a disabled element in IE can throw.
                    // See https://stackoverflow.com/a/1600194/2476884
                    console.error(e_1);
                    return [2 /*return*/, false];
                case 6: return [2 /*return*/];
            }
        });
    });
};
/**
 * True if the user prefers reduced motion, false otherwise.
 *
 * See https://css-tricks.com/introduction-reduced-motion-media-query/
 */
exports.prefersReducedMotion = function () {
    // See https://caniuse.com/#feat=matchmedia
    return (typeof window.matchMedia === "function" &&
        window.matchMedia("(prefers-reduced-motion: reduce)").matches);
};
/**
 * Scrolls an element into view.
 *
 * For smooth scrolling behavior you might want to use the smoothscroll
 * polyfill http://iamdustan.com/smoothscroll/
 *
 * If the user has indicated that they prefer reduced motion, the smoothScroll value will be ignored.
 *
 * @param element the element to scroll into view
 * @param smoothScroll true for smooth scrolling, false otherwise
 */
exports.scrollIntoView = function (element, smoothScroll) {
    // TODO support ScrollIntoViewOptions and respect block and inline even when not smooth scrolling.
    if (smoothScroll === void 0) { smoothScroll = false; }
    // Scrolling to the document element or the body is problematic
    // for a few reasons so we just scroll to `0, 0` instead.
    // See e.g. https://github.com/iamdustan/smoothscroll/issues/138
    if (element === document.documentElement || element === document.body) {
        exports.setScrollPosition({ x: 0, y: 0 }, smoothScroll);
    }
    else {
        if (!smoothScroll || exports.prefersReducedMotion()) {
            // Avoid passing anything to scrollIntoView() (when we can) to maximize browser compatibility.
            element.scrollIntoView();
        }
        else {
            try {
                element.scrollIntoView({ behavior: "smooth" });
            }
            catch (_a) {
                // If scrollIntoView with options throws, fall back on no options.
                // See https://github.com/frontarm/navi/issues/71
                element.scrollIntoView();
            }
        }
    }
};
/**
 * Scrolls an element into view if it is not currently visible.
 *
 * For smooth scrolling behavior you might want to use the smoothscroll
 * polyfill http://iamdustan.com/smoothscroll/
 *
 * If the user has indicated that they prefer reduced motion, the smoothScroll value will be ignored.
 *
 * @param target the element to scroll into view
 * @param smoothScroll true for smooth scrolling, false otherwise
 */
exports.scrollIntoViewIfRequired = function (target, smoothScroll, inViewport) {
    if (smoothScroll === void 0) { smoothScroll = false; }
    if (inViewport === void 0) { inViewport = exports.isInViewport; }
    var element = exports.elementFromTarget(target);
    if (element !== undefined && !inViewport(element)) {
        exports.scrollIntoView(element, smoothScroll);
    }
};
/**
 * Focuses a specified element and then scrolls it (or another element) into view (if required).
 *
 * For smooth scrolling behavior you might want to use the smoothscroll
 * polyfill http://iamdustan.com/smoothscroll/
 *
 * If the user has indicated that they prefer reduced motion, the smoothScroll value will be ignored.
 *
 * @param focusTarget the element to focus
 * @param scrollIntoViewTarget the element to scroll into view
 * @param smoothScroll true for smooth scrolling, false otherwise
 */
exports.focusAndScrollIntoViewIfRequired = function (focusTarget, scrollIntoViewTarget, smoothScroll) {
    if (smoothScroll === void 0) { smoothScroll = false; }
    return __awaiter(void 0, void 0, void 0, function () {
        var elementToFocus, elementToScrollIntoView, preventScroll, result, _a;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    elementToFocus = exports.elementFromTarget(focusTarget);
                    elementToScrollIntoView = exports.elementFromTarget(scrollIntoViewTarget) || elementToFocus;
                    preventScroll = smoothScroll || elementToFocus !== elementToScrollIntoView;
                    _a = elementToFocus !== undefined;
                    if (!_a) return [3 /*break*/, 2];
                    return [4 /*yield*/, exports.focusElement(elementToFocus, preventScroll)];
                case 1:
                    _a = (_b.sent());
                    _b.label = 2;
                case 2:
                    result = _a;
                    if (elementToScrollIntoView !== undefined) {
                        // For screen users, scroll the element into view.
                        exports.scrollIntoViewIfRequired(elementToScrollIntoView, smoothScroll);
                    }
                    return [2 /*return*/, result];
            }
        });
    });
};
/**
 * Resets focus and scroll position after a SPA page navigation.
 *
 * Will attempt to move focus to the focusTarget, primaryFocusTarget,
 * document element and finally document body, in that order. If any of
 * those elements do not exist or cannot be focused, will attempt to
 * focus the next fallback element.
 *
 * For smooth scrolling behavior you might want to use the smoothscroll
 * polyfill http://iamdustan.com/smoothscroll/
 *
 * If the user has indicated that they prefer reduced motion, the smoothScroll value will be ignored.
 *
 * See: https://github.com/ReactTraining/react-router/issues/5210
 *
 * @param primaryFocusTarget a CSS selector for your primary focus target,
 * e.g. `main h1`.
 * @param focusTarget the element to focus, e.g. the element identified by
 * the hash fragment of the URL.
 * @param smoothScroll true for smooth scrolling, false otherwise
 */
exports.resetFocus = function (primaryFocusTarget, focusTarget, smoothScroll) {
    if (smoothScroll === void 0) { smoothScroll = false; }
    return __awaiter(void 0, void 0, void 0, function () {
        var elementToFocus, primaryFocusElement, targets, _i, targets_1, targetElement, didFocus, e_2;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    elementToFocus = focusTarget !== undefined ? exports.elementFromTarget(focusTarget) : undefined;
                    primaryFocusElement = exports.elementFromTarget(primaryFocusTarget);
                    targets = [
                        elementToFocus,
                        primaryFocusElement,
                        document.documentElement,
                        document.body,
                    ];
                    _i = 0, targets_1 = targets;
                    _a.label = 1;
                case 1:
                    if (!(_i < targets_1.length)) return [3 /*break*/, 6];
                    targetElement = targets_1[_i];
                    if (!(targetElement instanceof Element)) return [3 /*break*/, 5];
                    _a.label = 2;
                case 2:
                    _a.trys.push([2, 4, , 5]);
                    return [4 /*yield*/, exports.focusAndScrollIntoViewIfRequired(targetElement, targetElement, smoothScroll)];
                case 3:
                    didFocus = _a.sent();
                    if (didFocus) {
                        return [2 /*return*/, true];
                    }
                    return [3 /*break*/, 5];
                case 4:
                    e_2 = _a.sent();
                    console.error(e_2);
                    return [3 /*break*/, 5];
                case 5:
                    _i++;
                    return [3 /*break*/, 1];
                case 6: return [2 /*return*/, false];
            }
        });
    });
};
var createAnnounceDiv = function (id, politeness) {
    var div = document.createElement("div");
    div.setAttribute("id", id);
    div.setAttribute("role", "status");
    div.setAttribute("aria-live", politeness);
    div.setAttribute("aria-atomic", "true");
    // As per Bootstrap's sr-only styles.
    // See: https://a11yproject.com/posts/how-to-hide-content/
    // See: https://hugogiraudel.com/2016/10/13/css-hide-and-seek/
    // See: https://getbootstrap.com/docs/4.3/getting-started/accessibility/#visually-hidden-content
    // See: https://github.com/twbs/bootstrap/blob/ff29c1224c20b8fcf2d1e7c28426470f1dc3e40d/scss/mixins/_screen-reader.scss#L6
    div.style.position = "absolute";
    div.style.width = "1px";
    div.style.height = "1px";
    div.style.padding = "0";
    div.style.overflow = "hidden";
    div.style.clip = "rect(0, 0, 0, 0)";
    div.style.whiteSpace = "nowrap";
    div.style.border = "0";
    document.body.appendChild(div);
    return div;
};
/**
 * Make an announcement to screen reader users. Useful for page navigation events.
 *
 * See https://almerosteyn.com/2017/03/accessible-react-navigation
 * See https://getbootstrap.com/docs/4.3/utilities/screen-readers/
 * See https://github.com/twbs/bootstrap/blob/ff29c1224c20b8fcf2d1e7c28426470f1dc3e40d/scss/mixins/_screen-reader.scss#L6
 *
 * @param message the message to announce to screen reader users, e.g. "navigated to about page".
 * @param announcementsDivId a DOM ID of the visually hidden announcements element, e.g. "announcements".
 */
exports.announce = function (message, announcementsDivId, setMessageTimeout, clearMessageTimeout, politeness) {
    if (announcementsDivId === void 0) { announcementsDivId = "announcements"; }
    if (setMessageTimeout === void 0) { setMessageTimeout = 50; }
    if (clearMessageTimeout === void 0) { clearMessageTimeout = 500; }
    if (politeness === void 0) { politeness = "polite"; }
    var announceDiv = document.getElementById(announcementsDivId) ||
        createAnnounceDiv(announcementsDivId, politeness);
    var p1 = new Promise(function (resolve) {
        setTimeout(function () {
            announceDiv.innerText = message;
            resolve();
        }, setMessageTimeout);
    });
    var p2 = new Promise(function (resolve) {
        setTimeout(function () {
            announceDiv.innerText = "";
            resolve();
        }, clearMessageTimeout);
    });
    return Promise.all([p1, p2]);
};
/**
 * Like `closest()` but stops ascending the ancestor tree once it hits the specified form element.
 */
exports.closestInsideForm = function (element, selector, form) {
    if (element === form || element.parentElement === null) {
        return undefined;
    }
    else if (element.matches(selector)) {
        return element;
    }
    else {
        return exports.closestInsideForm(element.parentElement, selector, form);
    }
};
/**
 * Focuses and scrolls into view the first invalid form element inside
 * a given form.
 *
 * Call this function after you have validated a form and identified errors.
 *
 * See https://webaim.org/techniques/formvalidation/
 *
 * For smooth scrolling behavior you might want to use the smoothscroll
 * polyfill http://iamdustan.com/smoothscroll/
 *
 * If the user has indicated that they prefer reduced motion, the smoothScroll value will be ignored.
 *
 * For IE support you might want to use the closest() polyfill from https://developer.mozilla.org/en-US/docs/Web/API/Element/closest#Polyfill
 *
 * @param formTarget the form element to focus or a CSS selector that uniquely identifies the form to focus, e.g. `#search-form`.
 * @param invalidElementSelector the CSS selector that is used to identify invalid elements within a form, e.g. `[aria-invalid="true"]`.
 * @param elementWrapperSelector the CSS selector that matches the "wrapper" element--the closest ancestor of the form input--that contains
 *                               both the form input and its label.
 *                               This wrapper element will be scrolled into view so that both the invalid input and its label are visible.
 * @param smoothScroll true for smooth scrolling, false otherwise
 */
exports.focusInvalidForm = function (formTarget, invalidElementSelector, elementWrapperSelector, smoothScroll) {
    if (smoothScroll === void 0) { smoothScroll = false; }
    var form = exports.elementFromTarget(formTarget);
    if (form === undefined) {
        console.warn("No form matching [" + formTarget + "] found in document. Users of keyboards, screen readers and other assistive technology will have a degraded experience.");
        return Promise.resolve(false);
    }
    var firstInvalidElement = exports.elementFromTarget(invalidElementSelector, form);
    if (firstInvalidElement === undefined) {
        // TODO: In this case should we focus and scroll to the form itself?
        console.warn("No invalid form element matching [" + invalidElementSelector + "] found inside form [" + formTarget + "]. Users of keyboards, screen readers and other assistive technology will have a degraded experience.");
        return Promise.resolve(false);
    }
    var firstInvalidElementWrapper = elementWrapperSelector !== undefined &&
        typeof firstInvalidElement.matches === "function"
        ? exports.closestInsideForm(firstInvalidElement, elementWrapperSelector, form)
        : undefined;
    return exports.focusAndScrollIntoViewIfRequired(firstInvalidElement, firstInvalidElementWrapper || firstInvalidElement, smoothScroll);
};
